# 数据库理论

## 管理数据的历史方式

* 人工管理
  * 数据不(长期)保存
  * 没有专用的软件对数据进行管理
  * 数据不共享
  * 数据不具有独立性
* 文件系统
  * 数据以文件形式长期保存
  * 由文件系统管理数据
  * 程序与数据之间有一定的独立性
  * 文件的形式多样化
  * 数据有一定的共享性，但较差
  * 数据冗余度大、不一致性、独立性差，联系弱
* 数据库系统DBS
  * 包括数据库DB、硬件、软件（核心是数据库管理系统DBMS）、人员（数据库设计人员、应用程序员、最终用户、数据库管理员DBA）
  * 结构化的数据及其联系的集合
  * 数据共享性高、冗余度低、独立性高
  * 有统一的数据管理和控制功能：安全性、完整性（实体、参照、用户自定义）、并发、数据恢复

## 数据库系统的三级模式结构

* 外模式、内模式、概念模式/模式
* 外模式反映了数据库的用户观，对应于用户级、视图层、DML
* 内模式反映了数据库的存储观，对应于物理级、储存文件；如数据是顺序储存还是B树还是Hash，是否压缩和加密
* 模式对应逻辑层、DDL、基本表
* 一个数据库只有一个内模式，也只有一个模式
* 三级模式之间提供了两级映像，实现了模式的相互转换，提高了独立性
* 其中内模式改变时要修改“模式/内模式”映像，保证物理独立性；逻辑改变时要修改“外模式/概念模式”映像，保证逻辑独立性

## ER图

* 属于概念数据模型，概念设计阶段
* 实体Entity，用矩形
* 属性Attribute，用椭圆
  * 简单属性（不特别说明一般指此）、复合属性（如家庭地址）
  * 单值属性、多值属性
  * 派生属性：由其它属性计算得到，如已知出生日期求年龄
  * 下划线为主键
* 联系Relationship，用菱形
* 实体与联系之间用直线连接，单条直线上写1或*
  * 两个实体之间可以1:1、`1:*`、`*:*`
  * 三个实体之间可存在1:1:1、`1:1:*`、`1:*:*`、`*:*:*`，此时三者连在同一个菱形上，这种语义不同于两两之间多对多
  * 一个实体内的二元联系：实体与菱形之间有多条直线，因为联系的两者是同一个实体。如职工与婚姻联系是1:1的，职工与领导与被领导联系是1:*的
* 扩充
  * 弱实体：两个矩形，表示通过联系依赖另一个实体，如果另一个实体不存在自己也就不存在
  * 特殊化：类似于OO的继承。大概是实体两直线连到圆圈，圈里o表示子类可能重叠（两个子类不冲突，可以同时具有），d表示不重叠；直线上加个弧线，连到左右两边加竖线的矩形子类实体

### 属性冲突

* 属性域冲突（重点）
  * 属性值的类型
  * 取值范围
  * 取值集合不同
  * 学号：有些部门将其定义为数值型，而有些部门将其定义为字符型
  * 年龄：有的可能用出生年月表示，有的则用整数表示
* 属性取值单位冲突
  * 零件的重量：有的以公斤为单位，有的以斤为单位，有的则以克为单位

### 命名冲突

* 同名异义
  * 不同意义的对象在不同的局部应用中具有相同的名字
  * “单位”在某些部门表示为人员所在的部门，而在某些部门可能表示物品的重量、长度等属性
* 异名同义（一义多名）
  * 同一意义的对象在不同的局部应用中具有不同的名字
  * 在教务管理部门中的“教室”，在后勤管理部门中的“学生宿舍”，对应的都是“房间”这个概念

### 结构冲突

* 同一对象在不同应用中具有不同的抽象
  * 教师的职称在某一局部应用中被当作实体，而在另一局部应用中被当作属性
  * 解决方法：使同一对象在不同应用中具有相同的抽象，或把实体转换为属性，或把属性转换为实体。一般情况下，凡能作为属性对待的，应尽量作为属性
* 同一实体在不同分E-R图中所包含的属性个数和属性排列次序不完全相同
  * 解决办法：合并后实体的属性组成为各局部E-R图中的同名实体属性的并集，然后再适当调整属性的次序
* 实体之间的联系在不同局部视图中呈现不同的类型
  * 解决方法：根据应用的语义对实体联系的类型进行综合或调整

## 基本数据模型

* 数据模型的三要素：数据结构、数据操作、数据约束
* 层次模型：用横着的大矩形表示实体，中间分了很多块表示属性，用箭头指向另一个实体表示一对一或一对多，无法直接表示多对多
* 网状模型
* 关系模型：用 Stu(Sno, Sname) 这种方式表示
* 面向对象数据模型

## ER模型向关系模型的转换

* 一个实体转换为一个关系模式
* 联系的转换

### 实体间的联系是1∶1联系

* 可以在两个实体类型转换成的两个关系模式中的任意一个关系模式的属性中，加入另一个关系模式的主码和联系本身的属性
* 一个部门只有一个负责人
    部门（部门号，部门名，职工号）
    职工（职工号，姓名，性别），并在两者之间建立外键

### 若实体间的联系是1∶n联系

* 在n端实体类型转换成的关系模式中，加入1端实体类型转换成的关系模式的主码和联系类型的属性
* 系（系号，系名）
    教师（教师号，姓名，职称，系号），系号是外键

### 若实体间的联系是m∶n联系

* 将联系类型也转换成关系模式，其属性为两端实体类型的主码加上联系类型的属性，而该主码为两端实体主码的组合
* 学生（学号，姓名）
    课程（课程号，课程名，学分）
    选修（学号，课程号，成绩），学号、课程号为外键

## 关系数据库理论

### DBMS的功能

* 数据定义(Data Define Language)：CREATE、DROP、ALTER。保存在数据字典(Data Dictionary)中
* 数据查询：SELECT
* 数据操纵(Data Manipulation Language)：INSERT、UPDATE、DELETE
* 数据控制：GRANT、REVOLK
* 数据库建立、维护、运行、管理
* 数据通信接口
* 数据组织、储存和管理

### 关系模型

* 属性：如学生的姓名、性别、学号；属性的个数称为“元数”
* 域：属性的取值范围的集合（一组具有相同数据类型的值的集合）：如性别的域为{男，女}
* 候选键/关键字：唯一标识一个元组的某一属性或某属性组
* 主键/主关键字：若一个关系有多个候选键，选定其中一个为主键
* 主属性：包含在候选键中的属性
* 全码：所有属性是这个关系模式的候选码
* 关系模式：关系名(属性名)，主键用下划线，外键用虚线，或如果名字不同就要加逗号Dom(xx)=xxx；对应表结构
* 关系：n个集合的笛卡尔积的子集
* 目或度：关系中的n
* 元组：(值)；元组的个数称为“基数”，即有多少条记录
* 分量：元组的某个属性值
* 关系实例
* 关系代数：并∪（要忽略重复的）、差－、交∩、笛卡儿积×（重名的加关系名和点）、选取σ（条件写在右下角，表示且用∧，括号内可为其它运算结果）、投影π（选取的列写在右下角用逗号）、连接（直角无穷符号，下面写X=Y的列条件，也可用不等的比较符号）、除法（A表有c1,c2两列，B表有c2一列，A除以B就是A中那些完整含有B表的c1的行）
* 性质：列同质、不同列可来自于同一域、列和元组的顺序可以任意交换、不允许出现完全相同的元组、每一分量必须不可再分（第一范式）
* 元组演算、域演算：如`{t1t2|(∃u4u5)(S(t1t2'男',u4u5)∧u5<20)}`，本质与SQL语句类似，t1t2是要选取的列，S是表，常量直接写，u4u5是非选取的列，是任意的，且能加条件
* 函数依赖：某一属性或元组决定另一属性或元组，表示为(A,B)->C。函数依赖集：略。最小函数依赖集：右边仅有一个属性、无多余的函数依赖、各函数依赖左边无多余属性
* 完全函数依赖、部分函数依赖、传递函数依赖：完全指只有主键能唯一推出其余的键；部分一般指{A->D,(A,B)->C}中，A是主键，导致自己推断的(A,B)->D是部分依赖；传递指A->B,B->C
* 平凡依赖：左边推出右边且右边是左边的子集，如(A,B)->B就是平凡（函数）依赖，A->A也是。一般讨论的主要是非平凡依赖
* 多值依赖：如在(课程C，教师T，参考书B)中，CTB都是主键。C的一个具体值有多个T与其对应，C与B也一样。一个确定的C值与T和B无关，TB之间无直接联系。C-->T，C-->B。函数依赖是多值依赖的特殊情形
* 平凡多值依赖：若X-->Y且Z为空

### 关系模式的范式（NF）

* 第一范式（规范化关系）：每个属性都是不可再分（原子）的，即不是数组
* 第二范式：消除部分函数依赖，分解后没有包含在主键中的列必须完全依赖于主键。如 (Sno, Sname, Cno, Score) 变成 (Sno, Sname) 和 (Sno, Cno, Score)，分解前是(Sno, Cno)联合主键，但Sname只依赖Sno，这样就不满足
* 第三范式：消除传递函数依赖，如SNo->Dept, Dept->MN。主属性之间仍可能存在部分依赖
* BC范式：消除所有属性的函数依赖，即第三范式上消除主属性的函数依赖（候选键之间不存在相互决定），如SNo<->SN, (SNo, CNo)->Score, (SN, CNo)->Score
* 第四范式：消除非平凡且非函数依赖的多值依赖，允许有平凡的多值依赖。CTB例中分解成(C,T)和(C,B)就满足了4NF，其中CT还是都是主键，且C-->T是平凡多值依赖
* 若只考虑函数依赖，BCNF是最高范式；考虑多值依赖，4NF是最高范式
* 第五范式/PJ范式/投影-连接范式：连接依赖

#### 第一范式存在的问题

* 数据冗余：同一数据储存多次
* 插入异常：把本来可以为空的属性做了主键，插入那样的数据的时候会无法进行
* 删除异常：把某个表清空的时候，如果有别的属性依附在上面，也会消失
* 更新异常：改了一些数据，未改另一些数据，造成数据不一致性

### Armstrong公理系统和推理规则

* 设R(U,F)，R是关系模式，U是属性集，F是函数依赖
* 自反：若Y⊆X⊆U，则X->Y
* 增广：若X->Y，则XZ->YZ
* 传递：若X->Y, Y->Z，则X->Z
* 合并：若X->Y, X->Z，则X->YZ
* 伪传递：若X->Y, WY->Z，则XW->Z（因为X->Y => WX->WY->Z，不知道为什么会写成XW）
* 分解：若X->Y, Z⊆Y，则X->Z

### 属性的闭包

* 给一个初始属性集，根据函数依赖从左往右推导，每次都全部过一遍依赖，把结果用作下一轮，直到不再获得新的
* 用字符表示，(AB)+表示求初始属性为AB的闭包，X(0)=AB，找A->,B->,AB->，得到X(1)=xxx

### 候选键的求解方法

* 把属性分为L、R、N、LR四类，其中L表示仅出现在函数依赖集左边的属性，N表示在属性集里但不出现在函数依赖集里的属性
* L类必为所有候选键成员之一
* R类不在任何候选键中
* N类必为所有候选键的成员之一
* 若存在X⊆{L,N}且X+包含所有属性，则X是唯一候选键
* 如果没有L和N类的属性，要把LR中的每个属性找一下闭包；但如果有L类的，那就要把LR中的一个个拿出来和L类的属性合在一起，找闭包

### 模式分解

* 判断分解后是否是无损连接：对于分解成两个，取交集，相互取差集，如果关系模式中存在该交集->任意一个差集，则无损；分解成两个以上需要列表格，太复杂了
* 将关系模式转成3NF且保持函数依赖、且无损连接、BCNF：太复杂了
