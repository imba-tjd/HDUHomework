# 数据库理论

* 题库：https://noobdream.com/Practice/database/
* 视频：https://space.bilibili.com/296788528/lists/1477747

## 管理数据的历史方式

* 人工管理
  * 数据不(长期)保存
  * 没有专用的软件对数据进行管理
  * 数据不共享
  * 数据不具有独立性
* 文件系统
  * 数据以文件形式长期保存
  * 由文件系统管理数据
  * 程序与数据之间有一定的独立性
  * 文件的形式多样化
  * 数据有一定的共享性，但较差
  * 数据冗余度大、不一致性、数据孤立，联系弱
* 数据库系统DBS
  * 包括数据库DB、硬件、软件（核心是数据库管理系统DBMS）、人员（数据库设计人员、应用程序员、最终用户、数据库管理员DBA）
  * 结构化的数据及其联系的集合
  * 数据共享性高、冗余度低、独立性高（不同应用程序可以操作这些数据）
  * 有统一的数据管理和控制功能，也是DBMS的主要功能：安全性、完整性、并发、数据恢复

## DBS三级模式结构

* 外模式（子模式、视图）、模式（逻辑模式、概念模式、公共视图）、内模式（物理模式）
  * 外模式反映了数据库的用户观，对应于用户级、视图层、DML
  * 模式对应逻辑层、DDL、基本表
  * 内模式反映了数据库的存储观，对应于物理级、储存文件。如数据是顺序储存还是B树还是Hash，是否压缩和加密
* 一个数据库只有一个内模式，也只有一个模式
* 三级模式之间提供了两级映像，实现了模式的相互转换，提高了独立性
  * 数据独立性：内模式改变时要修改“模式-内模式”映像，保证物理独立性；逻辑改变时要修改“外模式-概念模式”映像，保证逻辑独立性
* 分布式数据库
  * {局部数据库 - 局部内模式 - 局部概念模式} x N - 分配模式（物理） - 分片模式（逻辑） - 全局概念模式（使得如同没有分布式一样） - {全局视图}（全局外模式）
  * 局部映像透明性（逻辑透明性，最基本）、位置透明性（如将数据从一个站点转移到另一个站点，应用程序不受影响）、复制透明性（系统自动完成复制）、分片透明性

## 数据库设计

步骤：需求分析（调查、数据流图、数据字典；是最耗时最困难的阶段）、概念结构设计（ER图）、逻辑结构设计（ER图转关系模式、规范化和反规范化、确定完整性约束、用户视图）、物理结构设计、数据库实施、数据库运行和维护。

### 数据模型

* 三要素：数据结构、数据操作、数据约束
* 从应用层次区分：概念数据模型、逻辑数据模型（如关系模型、对象模型）、物理数据模型
* 主要的数据模型
  * 层次模型：树形结构，用横着的大矩形表示实体，中间分了很多块表示属性，用箭头指向另一个实体表示一对一或一对多，无法直接表示多对多
  * 网状模型：有向图
  * 关系模型：用 Stu(Sno, Sname) 这种方式表示，或说用二维表格表示
  * 对象模型
* 数据模型设计 属于逻辑结构设计

## ER图

* 属于概念数据模型，概念设计阶段
* 实体Entity，用矩形
* 属性Attribute，用椭圆
  * 简单属性（不特别说明一般指此）、复合属性（如家庭地址）
  * 单值属性、多值属性
  * 派生属性：由其它属性计算得到，如已知出生日期求年龄。一般不作为关系属性来存储
  * 下划线为主键
* 联系Relationship，用菱形
* 实体与联系之间用直线连接，单条直线上写1或*
  * 两个实体之间可以1:1、`1:*`、`*:*`
  * 三个实体之间可存在1:1:1、`1:1:*`、`1:*:*`、`*:*:*`，此时三者连在同一个菱形上，这种语义不同于两两之间多对多
  * 一个实体内的二元联系：一个实体与一个菱形之间有多条直线，因为联系的两者是同一个实体。如职工与婚姻联系是1:1的，职工与领导与被领导联系是1:*的
* 扩充
  * 弱实体：两个矩形，表示通过联系依赖另一个实体，如果另一个实体不存在自己也就不存在
  * 特殊化：类似于OO的继承。大概是实体两直线连到圆圈，圈里o表示子类可能重叠（两个子类不冲突，可以同时具有），d表示不重叠；直线上加个弧线，连到左右两边加竖线的矩形子类实体

### 属性冲突

* 属性域冲突（重点）
  * 属性值的类型
  * 取值范围
  * 取值集合不同
  * 学号：有些部门将其定义为数值型，而有些部门将其定义为字符型
  * 年龄：有的可能用出生年月表示，有的则用整数表示
* 属性取值单位冲突
  * 零件的重量：有的以公斤为单位，有的以斤为单位，有的则以克为单位

### 命名冲突

* 同名异义
  * 不同意义的对象在不同的局部应用中具有相同的名字
  * “单位”在某些部门表示为人员所在的部门，而在某些部门可能表示物品的重量、长度等属性
* 异名同义（一义多名）
  * 同一意义的对象在不同的局部应用中具有不同的名字
  * 在教务管理部门中的“教室”，在后勤管理部门中的“学生宿舍”，对应的都是“房间”这个概念

### 结构冲突

* 同一对象在不同应用中具有不同的抽象
  * 教师的职称在某一局部应用中被当作实体，而在另一局部应用中被当作属性
  * 解决方法：使同一对象在不同应用中具有相同的抽象，或把实体转换为属性，或把属性转换为实体。一般情况下，凡能作为属性对待的，应尽量作为属性
* 同一实体在不同分E-R图中所包含的属性个数和属性排列次序不完全相同
  * 解决办法：合并后实体的属性组成为各局部E-R图中的同名实体属性的并集，然后再适当调整属性的次序
* 实体之间的联系在不同局部视图中呈现不同的类型
  * 解决方法：根据应用的语义对实体联系的类型进行综合或调整

### ER模型向关系模型的转换

* 属于逻辑结构设计
* 一个实体转换为一个关系模式
* 联系的转换

#### 实体间的联系是1∶1联系

* 可以在两个实体类型转换成的两个关系模式中的任意一个关系模式的属性中，加入另一个关系模式的主键和联系本身的属性
* 一个部门只有一个负责人
  * 部门（部门号，部门名，职工号）
  * 职工（职工号，姓名，性别），并在两者之间建立外键

#### 若实体间的联系是1∶n联系

* 在n端实体类型转换成的关系模式中，加入1端实体类型转换成的关系模式的主键和联系类型的属性
* 系（系号，系名）
  * 教师（教师号，姓名，职称，系号），系号是外键

#### 若实体间的联系是m∶n联系

* 将联系类型也转换成关系模式，其属性为两端实体类型的主键加上联系类型的属性，而该主键为两端实体主键的组合
* 学生（学号，姓名）
  * 课程（课程号，课程名，学分）
  * 选修（学号，课程号，成绩），学号、课程号为外键

## DBMS的功能

* 数据定义(Data Define Language)：CREATE、DROP、ALTER。保存在数据字典(Data Dictionary)中
* 数据查询(Data Query Language)：SELECT
* 数据操纵(Data Manipulation Language)：INSERT、UPDATE、DELETE
* 数据控制(Data Control Language)：GRANT、REVOLK
* 数据库建立、维护、运行、管理
* 数据通信接口
* 数据组织、储存和管理

## 关系模型

* 术语
  * 属性Attribute：如学生的姓名、性别、学号，相当于表的“列”。属性(列)的个数称为“元数”或“目或度”Degree
  * 域Domain：属性的取值范围的集合（一组具有相同数据类型的值的集合）：如性别的域为{男，女}
  * 候选键Candidate Key/关键字/码：唯一标识一个元组的某一属性或某属性组（此定义实际上是超键，但做题一般选候选键）
  * 主键Primary Key/主关键字：若一个关系有多个候选键，选定其中一个为主键
  * 主属性：包含在任意一个候选键中的属性
  * 全码All-key：所有属性都是这个关系模式的候选键，无非主属性。如AB AC是两个候选键，则ABC是全码
  * 超键：若X的闭包为所有属性，则X为超键；当X不可约时即为（真正的）候选键
* 关系模式：关系名(属性名)，主键用下划线，外键用虚线
* 关系：n个(属性)集合的笛卡尔积的子集。另一种说法：关系模式的逻辑结构是二维表，这个二维表在关系模式中称为关系；关系的描述就是关系模式。或者关系是元组的集合，关系模式是列的类型定义
* 元组：(值1, 值2)，就是一行数据记录
  * 元组的个数称为“基数”，即有多少条记录
  * 分量：元组的某个属性值
* 关系实例
* 性质：列同质、不同列可来自于同一域、列和元组的顺序可以任意交换、不允许出现完全相同的元组、每一分量必须不可再分（第一范式）
* 完整性约束
  * 实体：主键非空、唯一
  * 参照：外键不能引用不存在的主键
  * 用户自定义：UNIQUE、CHECK等
* 元组演算、域演算：如`{c1c2|(∃u4u5)(S(c1c2'字面量',u4u5)∧u5<20)}`，本质与SQL语句类似，c1c2是要选取的列，S是表，字面量直接写，u4u5是非选取的列，是任意的，且能加条件

### 关系代数运算

* 并∪ 要忽略重复的
* 差－
* 交∩ 等于A-(A-B)
* 笛卡尔积× 重名的加关系名和点
* 选取σ Selection 相当于Where。条件写在右下角，表示且用∧，括号内可为其它运算结果
* 投影π Projection 相当于Select。选取的列写在右下角用逗号
* 连接 直角无穷符号，下面写X=Y的列条件，也可用不等的比较符号，也称为θ连接。自然连接：下面不写比较符号，隐含=，且结果中去掉重复列
  * 外连接 如左外连接是 直角无穷符号 左边上下延长两横
* 除法 A表有c1,c2两列，B表有c2一列，A除以B就是A中那些完整含有B表的c1的行。或B表还可以有其它的不在A中的列，不影响结果
* 五种基本运算：并、差、笛卡尔积、选取、投影
* 如：π 1,2 (σ 1=3∧2>4 (R×S))。如果想按名称选用于join的列，写法类似 R.C

### 函数依赖

* 某一属性或元组决定另一属性或元组，表示为(A,B)->C
* 完全函数依赖、部分函数依赖、传递函数依赖
  * 完全指只有主键能唯一推出其余的键。如X->Y，则X的任意真子集都不能推出Y
  * 部分指如{A->D,(A,B)->C}中，AB是主键，导致推断出来的(A,B)->D是部分依赖，因为只需A就能->D
  * 传递指A->B,B->C
* 平凡函数依赖：左边推出右边且右边是左边的子集，如(A,B)->B、A->A。一般主要讨论非平凡依赖
* 多值依赖：如在(课程C，教师T，参考书B)中，CTB都是主键。C的一个具体值有多个T与其对应，C与B也一样。一个确定的C值与T和B无关，TB之间无直接联系。C-->T，C-->B。函数依赖是多值依赖的特殊情形
* 平凡多值依赖：若X-->Y且Z为空

### 关系模式的范式（NF）

* 用于消除数据冗余，保证数据一致性和完整性
* 第一范式（规范化关系）：每个属性都是不可再分（原子）的，即不是数组
* 第二范式：消除部分函数依赖，分解后没有包含在主键中的列（非主属性）必须完全依赖于主键。如 (Sno, Sname, Cno, Score) 变成 (Sno, Sname) 和 (Sno, Cno, Score)，分解前是(Sno, Cno)联合主键，但Sname只依赖Sno，这样就不满足
* 第三范式：消除传递函数依赖，如SNo->Dept, Dept->MN
  * 前两条都只消除非主属性的，主属性之间仍可能存在依赖
* BC范式（巴克斯范式）：消除所有属性的函数依赖，即第三范式上消除主属性的函数依赖，候选键之间不存在相互决定。如SNo<->SN, (SNo, CNo)->Score, (SN, CNo)->Score
* 第四范式：消除非平凡且非函数依赖的多值依赖，允许有平凡多值依赖。CTB例中分解成(C,T)和(C,B)就满足了4NF，其中CT还是都是主键，且C-->T是平凡多值依赖
* 若只考虑函数依赖，BCNF是最高范式；考虑多值依赖，4NF是最高范式
* 第五范式/PJ范式/投影-连接范式：连接依赖
* 全码的最低范式是3NF，最高是BCNF

#### 第一范式存在的问题

* 数据冗余：同一数据储存多次。浪费空间。是数据不一致的根本原因
* 插入异常：如计划开新课，由于没人选修，没有学号关键字，只能等有人选修才能把课程和学分存入。对于第二范式来说已经基本消除了
* 删除异常：若学生已经结业，从当前数据库删除选修记录，就会可能连课程号及学分完全从数据库中删除
* 更新异常：改了一些数据，未改另一些数据，造成数据不一致性

### 属性集和函数依赖集的闭包

* 属性集的闭包
  * 指由一个(或多个)属性直接或间接推导出的所有属性的集合
  * 给一个初始属性集(A,B)是总属性集U的子集，根据函数依赖F从左往右推导，每次都全部过一遍依赖，把结果用作下一轮，直到不再获得新的
  * 例如：(AB)F+或(AB)+表示求初始属性为AB，函数依赖集为F的闭包，X(0)=AB，则在F中找A->,B->,AB->，得到X(1)=xxx
* 函数依赖集(覆盖)
  * 理论上是按Armstrong公理推导，实际不这么操作
  * 例如：对于关系模式R(ABC)，F＝{A→B,B→C}，求F+。结果有八项：AB->φ空集 AB->A AB->B AB->AB AB->C AB->AC AB->BC AB->ABC
* 最小函数依赖集(最小覆盖)
  1. 右边仅有一个属性：如A->BC拆成A->B A->C
  2. 无多余的函数依赖：如果删除某条后，看该条左边的属性能否在剩下的函数依赖中推导得到该条右边的属性，如果能则说明该条是多余的
  3. 各函数依赖左边无多余属性：如A->B AC->B则后者可删。复杂的做法：对于每个左边有多个属性的，去掉一个属性，对剩下的左边的属性求闭包，如果能推导出右边的，则那个属性是多余的
  * 做完3后如果发生了改变，必须再做一遍2，或者也可以先做3再做2
  * 做完后如果有A->B A->C，可合并为A->BC

### 候选键的求解方法

* 把属性分为L、R、N、LR四类，其中L表示仅出现在函数依赖集左边的属性，N表示在属性集里但不出现在函数依赖集里的属性
* L类必为所有候选键成员之一
* R类不在任何候选键中
* N类必为所有候选键成员之一
* 若X={L,N}且X+包含所有属性，则X是唯一候选键
* 否则将LR中每一个依次取出，与X一起做闭包（若不存在L和N即X为空也可，则相当于依次对LR做闭包），同上一步，此时结果候选键可能有多个。还没有就依次一次取两个
* 作图法：把函数依赖画成有向图，属性作为结点，依赖作为边。从哪些点出发可以遍历所有点

### 关系模式分解

* 特性（原则）
  * 数据内容的等价性（分解的无损连接性、Lossless Decomposition）：分解后的数据内容与原始数据内容相比不能多也不能少，通过自然连接操作可以重构出原始的关系模式
    * 判断分解后是否是无损连接
      * 分解成两个关系模式的做法：取属性集U的交集，再相互取差集，如果关系模式中存在该交集->任意一个差集，则无损。即U1∩U2->U1-U2或U2-U1
      * 分解成两个以上需要列表格，太复杂了
  * 数据约束的等价性（分解的保持依赖性、FD Preserved）：分解后的数据约束（依赖关系）等不能丢失。对于F中的每一个函数依赖，其左部属性都在某个子模式中有出现，并且右部属性也在同一个或几个子模式中通过某种方式保持这种依赖关系
    * 如U={A,B,C}, F={A->B, B->C}，分解为R1={U1={A,B},F1} R2={U2={A,C},F2}，对于A->B分解到了R1，但B-C则丢失了
* 保持无损连接的最高分解：4NF。保持函数依赖的最高分解、两者同时保持的最高分解：BCNF
* 将关系模式转成3NF且保持函数依赖、且无损连接、BCNF：太复杂了
* https://blog.csdn.net/prdslf001001/article/details/80336835 https://zhuanlan.zhihu.com/p/453156765 https://zhuanlan.zhihu.com/p/373759399

### Armstrong公理系统和推理规则

* 设R(U,F)，R是关系模式，U是属性集，F是函数依赖。以下前三项是公理，后面的是推论
* 自反：若Y⊆X⊆U，则X->Y
* 增广：若X->Y，则XZ->YZ
* 传递：若X->Y, Y->Z，则X->Z
* 伪传：若X->Y, WY->Z，则XW->Z（因为X->Y => WX->WY->Z）
* 合并：若X->Y, X->Z，则X->YZ
* 分解：若X->YZ，则X->Y X->Z
* 伪增(复合、合成)：若X->Y，W->Z，则XW->YZ
* 扩展：若X->Y，则X->XY

## 事务

* 事务：一系列操作，要么都做，要么都不做
* 事务特性：ACID
  * 原子性：要么全做，要么全不做
  * 一致性：如银行转帐，执行前后两个帐户金额之和应保持不变
  * 隔离性：对并发执行的事务T1 T2，在T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始
  * 持久性：事务一旦提交，对数据库的改变是永久性的

### 封锁机制

* 不一致性（冲突）
  * 丢失更新：并发操作时，T2把T1的结果修改覆盖掉。课件如此，但理论上这应该叫脏写
  * 污读：T1更新了数据，T2读取了更新后的数据，T1由于某种原因被撤销，修改无效，数据恢复原值。T2得到的数据与数据库不一致
  * 不可重读：T1读取了数据，T2读取并更新了数据，当T1再读取数据进行核对，得到的值不一致
* 排他锁（X锁、写锁），共享锁（S锁、读锁）
* 封锁协议
  * 一级：事务在修改数据之前先对其加X锁，直到**事务结束**才释放
  * 二级：在一级基础上，事务在读取数据之前先对其加S锁，**读完**后即释放S锁
  * 三级：在一级基础上，事务在读取数据之前先对其加S锁，直到**事务结束**才释放
  * 一级可防止丢失修改，二级可进一步防止读脏数据，三级可进一步防止不可重复读
* 两阶段封锁协议2PL
  * 第一阶段：扩展阶段。事务可以不断地获取新的锁
  * 第二阶段：收缩阶段。在准备提交或发生异常需要回滚时发生，这个阶段事务只能释放已持有的锁
* 串行调度：即任何时候都只有一个事务处于活动状态，每个事务的操作在其前一个事务完成之后才开始执行，不存在并发操作，因此不会出现数据竞争和死锁等问题
  * 可串行化调度：多个事务并发执行的一种方式，其结果与某个串行调度的结果等效
  * 冲突可串行化调度：如果一个并发调度可以通过调整非冲突操作的顺序转换为串行调度，同时保留冲突操作的原始顺序不变，那么这个并发调度就被认为是冲突可串行化的
  * 遵守两阶段锁是可串行化调度的充分条件

## 故障和恢复

* 故障：预期、非预期。系统故障(软故障)需OS重启的如停电、介质故障(硬故障)、病毒
* 恢复：冗余。数据转储、日志文件
* 事务恢复：发生故障时，所有已提交的事务都反映在数据库中
  * 在检查点前完成的，无需任何操作
  * 在故障前已提交（但还没遇到下一个检查点）的，前滚(恢复/重做)，正向扫描日志
  * 在故障前未提交的，回滚，反向扫描日志
* UNDO/ROLLBACK日志（撤销日志）
  * 记录事务在修改数据前的旧值或者修改动作的逆操作
  * 对于INSERT，记录插入的id，回滚时删除
  * 对于UPDATE，保存更新前的原始值，回滚时还原
  * 对于DELETE，记录被删除行的完整内容，回滚时插入
  * 在多版本并发控制MVCC中，还用于提供历史版本数据给其他未提交事务的查询
  * 可实现一致性和原子性
* REDO/WAL日志（重做日志）
  * 记录对数据库所做的修改操作的具体内容和修改方式，即对数据库页或记录的物理修改操作序列
  * 简单来说就是事务已提交到内存中但未合并到磁盘上，则在本日志中记录事务做的修改操作
  * 可实现持久性
* 登记日志的原则
  * 按事务执行顺序登记
  * 先写日志，后写数据库

## 其它问题

### SQL语句的执行过程

1. 解析与编译
  * SQL语句首先由数据库服务器接收并进行语法解析，将其转化为可执行计划。
  * 代价：相对较小，但在高并发场景下频繁地重新编译SQL语句或遇到复杂的动态SQL时，这个代价可能会累积。
2. 查询优化
  * 数据库根据表结构、统计信息以及可用索引等信息，决定如何执行SQL语句，生成执行计划。
  * 代价：如果涉及到复杂的查询逻辑或者存在大量潜在的执行路径，优化器计算最优计划的代价可能较大，但是一旦生成计划后通常会被缓存重用。
  * 早期剪枝、合并相同操作、使用索引统计信息
3. 执行计划
  * 按照生成的执行计划实际执行SQL语句，这可能包括索引查找、排序、连接操作、聚合函数计算、临时数据的创建与管理等。
  * 代价：主要开销，尤其当涉及到磁盘I/O操作（如全表扫描或索引扫描）、CPU密集型计算（如排序、聚合）或网络通信（分布式查询）时。
  * 索引使用：如果查询能有效利用索引，则I/O成本显著下降。
  * 数据读取：磁盘I/O通常是性能瓶颈，内存中的数据访问速度快得多。
  * 锁定与并发控制：取决于并发程度和锁的粒度，可能带来额外的等待时间和冲突解决开销。
4. 网络传输
  * 将查询结果从数据库服务器传输到客户端应用。
  * 代价：如果结果集很大，网络带宽和延迟成为影响性能的因素。

### 优化

1. 索引优化：
  * 添加合适的索引：针对频繁出现在查询条件、连接条件以及排序中的列创建索引，可以极大提升查询速度。合理选择索引类型，如B树索引、哈希索引、全文索引等。
  * 避免过度索引：过多的索引会导致插入、更新操作变慢，也会占用更多存储空间，所以要避免在更新频繁或选择性较差的列上创建索引。
2. SQL查询优化：
  * 重构SQL语句：尽量简化查询，避免全表扫描，使用连接取代子查询，优化GROUP BY和ORDER BY语句，减少不必要的运算。
  * 使用EXPLAIN分析SQL执行计划：理解查询是如何执行的，查看是否存在全表扫描、索引未被使用等情况，并据此优化。
3. 数据表结构优化：
  * 数据冗余去除：避免在多个地方存储相同的数据，减少数据不一致性和存储浪费。
  * 表拆分：根据业务需求进行水平拆分（sharding）和垂直拆分（partitioning），分散数据存储压力。
  * 字段设计优化：合理设置字段类型和长度，减少存储空间。
4. 事务与并发控制优化：
  * 适当使用事务隔离级别：在保证数据一致性的同时，最小化锁的范围和持续时间，减少事务间的阻塞。
  * 分区表：在大型表上运用分区技术，提高大表查询和管理效率。
5. 缓存机制：
  * 结果集缓存：对常用查询结果进行缓存，减少对数据库的直接查询。
6. 硬件与资源配置：
  * 硬件升级：增加内存、使用更快的磁盘、增加CPU核心数等，以提高处理能力和响应速度。
  * 资源调优：合理配置数据库服务器参数，如缓冲池大小、连接数、日志设置等。
7. 架构优化：
  * 读写分离：将读操作和写操作分担到不同的服务器或实例上，减轻主库压力。
  * 分布式数据库：在大规模并发场景下，采用分布式数据库架构以横向扩展能力。
8. 定期维护：
  * 数据清理：定期删除无用的历史数据，减少存储负担。
  * 重建索引和碎片整理：在合适的时间窗口内进行索引重建和表整理，优化物理存储结构。
9. 监控与分析：
  * 使用数据库性能监控工具，跟踪慢查询、锁争抢等问题，及时发现并解决问题。
  * 分析数据库日志，识别性能瓶颈和潜在问题。

### Codd提出的完全关系型的12条严格标准

信息准则、确保访问准则、空值的系统处理准则、基于资源管理的动态、联机目录、统一易用数据子语言、视图更新准则、高级插入、修改及删除操作、物理数据独立性、逻辑数据独立性、数据完整性准则、分布独立性、无损害原则

### 分区类型

* 水平分区：又称Sharding，是指将表的行水平切分成多个子集，每个子集包含表的一部分行和所有列
  * 范围分区：根据表中某一列的值的范围进行分区，例如，可以按照时间（如按年份或月份）、连续数值或其他有序的标识符来划分数据
  * 列表分区：根据列的特定值列表进行分区，适用于列的取值集合有限且不是连续范围的情况，例如区域代码、产品类别或状态标识
  * 散列分区：使用散列函数计算列的散列值，然后根据散列值的模数来分配行到不同的分区，目的是为了实现数据在各个分区之间的均匀分布
* 垂直分区：将一个表的列分割成两个或更多的表，每个表只包含原表的一部分列，但所有的行都还在。也可以称为列式存储或功能分区

### 树状结构存储

* 邻接表模型：使用非关系型查询方式，不管是自底向上的查询还是自顶向下查询，效率都是一样的
* 物化路径模型：用一个字段来表示层次结构，标识了父子关系，还固定了兄弟之间的顺序。自顶向下查询远比自底向上查询快
* 嵌套模型：通过左右节点标号的方式来确定每个节点的位置。以后续的方式深度优先编号。不管是自底向上还是自顶向下，其效率差别不大，只是在排序上有出入

### 设计数据库索引时需要考虑的主要因素

* 业务需求：明确哪些字段在实际应用中会被频繁用于查找、过滤、排序或分组
* 查询模式：分析查询执行计划，识别出SQL语句中WHERE子句、JOIN条件、ORDER BY和GROUP BY所涉及的字段，这些通常是需要索引的关键字段
* 索引维护成本：如果主要执行全表扫描或者频繁修改数据，且查询条件并不总是涉及特定索引字段，那么创建不必要的索引反而可能导致读取速度变慢
