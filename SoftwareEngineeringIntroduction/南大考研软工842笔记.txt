什么是软工：运用系统化、工程的方法开发软件；对这些方法的研究
典型的团队结构：主程序员 民主 开放

质量
模型/属性：功能性 可靠性 易用性 效率 可维护性 可移植性
验证：评审 测试 质量度量
配置项：需要进行配置管理的软件开发制品，包括最终制品和中间制品
基线：经过了评审验证的制品
配置管理活动：标识配置项 版本管理 变更控制 配置审计 状态报告 软件发布管理

需求
什么是需求：用户期望 系统能力 对它们的文档化表述
获取：面谈 集体获取 头脑风暴 原型
分析：边界分析 需求建模
层次：业务（为什么开发） 用户（具体任务期望） 系统（一次交互行为或实现细节）
分类：功能 性能（速度、承受多少人同时访问） 质量（可靠性、易用性如1个月熟练后能提升多少效率、安全相关、可维护性如1个月内移植到另一个环境） 接口 约束（如开发语言运行环境） 数据（要求储存一年内的操作记录）

需求建模
数据流（实体--信息-->动作->数据库）、ER图（对象+属性+关系）
用例图（人--任务）、交互图/顺序图（某对象/人<--进行动作，虚线返回数据-->另一对象/系统）、状态图

软件需求规格说明是需求开发的最终结果，它精确地阐述一个软件系统必须提供的功能和性能以及它所要考虑的限制条件。软件需求规格说明不仅是系统测试和用户文档的基础，也是所有子系列项目规划、设计和编码的基础。确认测试需要它。

软件设计
软件设计工程师以对象的目标和用户的需求为指引，在一定的客观约束条件下，通过分析、研究、建模等活动进行软件设计。
分层：高层（抽象设计决策）、中层（模块调用、类的协作）、低层（内部数据结构算法）
活动：分析设计出发点、建立候选方案、生成最终方案、评价
方法：结构化、面向对象、数据结构为中心、形式化
核心思想：抽象和分解。分解是横向将系统分割为几个相对简单的小系统，抽象是纵向聚焦各自的接口分离实现，二者一般一起使用

软件体系结构
规定了系统的计算部件和部件之间的交互
风格：主程序/子程序、面向对象、分层、MVC
设计过程：分析关键需求和项目约束、选择体系结构风格、逻辑(抽象)设计、物理(实现)设计、完善、定义接口、迭代3-6步

mock和stub：stub用于替换某些模块（实现），具有相同接口，实现简单。mock用于类间协作的集成测试，要非常简单
增量集成：自顶向下：要开发stub，只有一个dirver，底层验证被推迟，用于顶层稳定。自底向上：要开发很多driver，顶层验证被推迟，用于底层稳定
持续集成：尽早集成、频繁集成

测试层次：单元、集成（测试多个单元接口）、系统（测试全部单元接口）。前两者注重技术正确，后者注重需求和设计缺陷

黑盒测试也称功能测试或数据驱动测试，基于输入输出测试功能。测试方法：等价类划分、边界值分析、决策表、状态转换。测试用例要包含有效和无效的
白盒测试也称结构测试或逻辑驱动测试，按照程序内部的结构测试。测试方法：语句覆盖、路径覆盖、结构分支覆盖

人机交互界面设计原则：简洁、一致、易记、低出错率

软件构造：设计、编程、测试、调试、评审、构建、构造管理

重构：在不改变代码外部表现(即系统功能)的情况下改进其内部结构

维护的类型：完善、适应、修正、预防

软件生命周期模型：包含了软件从生产到报废的六个阶段：软件需求工程 软件设计 软件实现/构造 软件测试 软件交付 软件维护
常见模型：build-fix 瀑布 增量迭代 演化(需求驱动) 原型 螺旋(风险驱动)

verification（验证）于validation（确认或验收）的区别：Verification用于确定开发的软件是否符合**给定的规范或标准**，如动态测试、静态测试（如检查设计文档等不用运行产品），通常在软件开发早期进行。Validation用于确定开发的软件是否符合**客户的实际需求和期望**，通常在软件开发后期进行。相同点：都是保证软件质量
