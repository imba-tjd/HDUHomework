# 操作系统笔记

* 发展和分类
  * 手工操作：用户独占全机，人机速度矛盾，导致利用率低
  * 单道批处理：引入脱机输入输出技术，监督程序负责控制。但仅有一道程序运行，大量时间在等待IO
  * 多道批处理：程序并发执行。没有人机交互功能
  * 分时系统：解决了人机交互。不能优先处理紧急任务
  * 实时系统：及时性、可靠性。硬实时、软实时
  * 网络、分布式
* 操作系统的四个特征
  * 并发：多个事件宏观上同时发生，微观上交替发生
  * 共享：系统中的资源可供多个并发执行的进程共同使用。包括互斥共享和同时共享
  * 虚拟：把一个物理上的实体变为若干个逻辑上的对应物。包括空分复用（如虚拟内存）和时分复用（如虚拟处理器）
  * 异步：进程的执行以不可预估的速度前进
  * 前两者互为存在条件，是最基本的特征
  * 多道批处理、并发、操作系统 是一起诞生的
* 运行机制和体系结构
  * 处理器模式：r0特权指令，CPU核心态/管态。r3非特权指令，CPU用户态/目态
  * 程序状态字PSW：包括PC程序计数器、IR指令寄存器、CC条件码、中断屏蔽、内存保护等
  * 内核：时钟管理、中断处理、原语（一种特殊的程序，处于操作系统最底层接近硬件的部分，操作具有原子性，运行时间较短、调用频繁）。进程管理、存储器管理、设备管理
  * 大内核性能高，难维护；微内核功能少，结构清晰，性能低
* 中断和异常
  * 为了多道程序并发执行而诞生
  * 发生中断，CPU会从用户态进入核心态，也是唯一途径
  * 软中断/内中断/异常
    * 指令中断/自愿中断/访管中断/陷入trap
    * (硬件)故障fault：缺页。有可能被OS修复的
    * 软件中断/终止abort：除零异常
  * 硬中断/外中断：外设请求、人工干预。由CPU之外引起，与当前指令无关
  * 执行中断时要保护现场
  * 另一种说法：中断分为自愿性和强制性，强制性分为IO中断、程序中断、时钟中断等，缺页中断是程序中断
* 系统调用
  * 发出请求在用户态，进行处理在核心态
  * 陷入指令是唯一一个只能在用户态执行、不能在核心态执行的指令
  * 凡是与资源有关的操作、会直接影响其它进程的操作，一定需要OS介入，即需要系统调用

## 进程

* 引入多道程序技术后出现
* 进程实体/进程映像：PCB、程序段、数据段。本身是静态的，进程是进程实体的运行过程；但有时也可以把进程实体简称为进程
* PCB进程控制块：进程标识符PID、用户标识符UID、进程当前状态和优先级、资源分配清单、各寄存器的值
* 特性：动态、并发、独立、异步、结构
* 状态
  * 运行态（单核下只能有一个）、就绪态（具备运行条件但没有空闲CPU，或运行态时间片消耗完）、阻塞态/等待态（如系统调用、请求打印机）
  * 创建态（正在分配资源和PCB）、终止态
  * 唤醒：阻塞态->就绪态。当被阻塞进程所期待的事件出现时，将等待该事件的进程唤醒，如I/O完成
  * 就绪挂起、阻塞挂起。挂起的内存映像调到外存去了，没有分配资源，见中级调度和交换技术。激活：从外存调入内存
  * 不能由阻塞态直接转换为运行态，也不能由就绪态直接变为阻塞态
* 进程控制用原语实现，原语又用开关中断实现
* 进程通信
  * 共享存储：访问它必须互斥。分为基于数据结构的（低级、慢）和基于存储区的（高级）
  * 管道：特殊的共享文件，也要互斥。单个管道只能半双工：可以双向传输，但同一时间只能单向。读进程只能有一个
  * 消息传递通信：包括消息头和消息体。直接通信：把消息挂到接受者的消息缓冲队列上。间接通信：发给信箱
* 线程
  * CPU调度的基本单位
  * 每个线程有ID和线程控制块TCB
  * 同一个进程中的线程切换不会引起进程切换
  * 用户级线程（对操作系统透明）、内核级线程（真正的并发，但切换时消耗大）、二者组合。多对一、一对一、多对多

### 评价指标

* 提交时间、要求执行时间（运行时间）、开始执行时间、完成时间
* 周转时间（完成-提交）、带权周转时间（周转/运行）
* 平均周转时间（周转/作业数）、平均带权周转时间
* 等待时间（周转-运行-IO）、平均等待时间。作业的等待时间还要加上在外存后备队列中的等待时间，进程的不需要
* 响应时间（首次响应-提交）
* 吞吐量（作业数/总时间）
* CPU利用率（忙碌时间/总时间）

### 调度

* 层次
  * 高级调度（作业调度）：外存和内存，程序运行时调入一次，创建PCB；退出时调出一次，销毁PCB。后备队列
  * 中级调度（内存调度）：页面文件，提高内存利用率。PCB会常驻内存。可优先换出阻塞进程和优先级低的进程，放入挂起队列
  * 低级调度（进程调度）：最基本的调度，频率高
* 时机
  * 主动放弃、被动放弃
  * 不能进行调度：处理中断的过程中、处于操作系统内核程序临界区中（普通的临界区仍可能调度）、在原子操作中
* 狭义/广义：狭义的进程调度只指选中要运行的进程，不包含进程切换；广义的包含。进程切换：保存原来运行的进程的数据、恢复新进程的数据
* 批处理调度算法，交互性很糟糕
  * 先来先服务FIFO/FCFS：非抢占，不会饥饿，对长作业友好，公平
  * 短作业SJF/SPF：默认是非抢占的，也有抢占的最短剩余时间SRTN，周转和等待时间是最短的，可能长作业饥饿
  * 高响应比HRRN：1+等待/运行，非抢占，不会饥饿
* 交互式系统调度算法，重视响应时间
  * 时间片轮转RR：只用于进程调度（其它一般也能用于作业调度），抢占式（时钟中断）。过了一个时间片就把当前进程放到就绪队列尾，不会饥饿。时间片太大就会退化为FCFS，太小则切换进程花费大，一般认为切换进程开销占1%就是合适的
  * 优先级：需要存在优先级，可抢占也可非抢占。根据优先级是否可改变分为动态和静态，如果等待时间长，可以适当提高，如果运行时间长，可以适当降低。通常OS更偏好系统、前台、IO繁忙型进程。若高优先级源源不断，可能饥饿
  * 多级反馈队列：只用于进程调度，抢占式。先设定多个队列，优先级从高到低，时间片大小由小到大。新进程按FCFS进入第1级队列，若时间片用完则进入下一级，只有低级队列都为空时才会执行后面的队列；对于被抢占的进程或IO密集型，重新放入当前队列。具有其它算法的优点，可能饥饿
* 如果进行调度和切换需要时间：第一次从就绪态队列中选中也要算一次时间，其它进程等待的时间也要算前面的进程被调度花的时间

### 互斥

* 临界资源：一段时间内只允许一个进程使用的资源。临界区：访问临界资源的那段代码
* 原则
  * 空闲让进：不会两个都进不去
  * 忙则等待：不能两个同时进
  * 有限等待：不会死锁
  * 让权等待：等待时不是死循环空耗cpu
* 以下四种软件实现、三种硬件实现，都违反让权等待
* 单标志法
  * 思想：两个进程访问完临界区后把使用权限交给另一个进程
  * int turn=0表示允许哪个进程号进入临界区
  * 各进程用while(turn!=自己);表示不是自己时等待
  * 问题：进入临界区的权限只能被另一个进程赋予，两者必须交替访问，如果一开始P0不访问，那P1就无法进行，违背空闲让进
* 双标志先检查法
  * 用一个bool数组表示各进程是否想进入临界区
  * 各进程先用while(flag[别人]);表示等待其它进程在使用，之后flag[自己]=1，访问完后flag[自己]=0
  * 问题：因为异步性，如果检查完后还没来得及给自己赋值就切换了，会有多个进入临界区，违反忙则等待
  * 双标志后检查法：先上锁，再检查。违反空闲让进和有限等待
* Peterson皮特森算法
  * 两者的结合，先flag[自己]=1表示自己想进入临界区，又turn=别人表示“让梨”
  * 检查while(flag[别人]&&turn=别人);表示对方想进且最后一次是自己“让梨”则等待，如果对方想进且最后一次是别人“客气”，则自己进入
* 开关中断指令
  * 硬件实现。因为切换进程需要中断，如果关了，就切换不了了
  * 问题：只适用于单核、需要特权指令只有内核能用
* TestAndSet/TS/TSL指令
  * 硬件实现，原子操作
  * bool TS(bool* lock)先保存lock的值，无论原来的值是多少，让lock=1，再返回老的值
  * 使用者while(TS(&lock));当走出此循环时说明自己获得了锁（有别人把lock=0），执行完临界区后lock=0解锁
* Swap/Exchange/XCHG指令：基本同TSL。使用者while(old==true) Swap(&lock, &old);

### 信号量和同步

* PV原语，又称为wait和signal
* 整型信号量：int S=1表示资源数；P()中当S<=0时循环等待，之后S--；V()中S++。仍违反让权等待
* 记录型信号量（默认）
  * Semaphore结构体：value、等待队列L
  * block()阻塞自己并挂到等待队列中，会让出CPU；wakeup()从队列中让一个进程从阻塞态变为就绪态
  * P()中先value--，如果处理后小于0，表示资源不够，就block()。如果有多个进程进行P()，value就会出现-1 -2的情况，可理解为预定了，也可理解为注册回调
  * V()中先value++，如果处理后小于等于0，表示等待队列中存在进程，就wakeup()
* 互斥：初值为1的信号量，又称为mutex。使用临界区前P()，用完了V()，在同一个进程中执行
* 同步：为每一个前驱关系（需要保证两个操作的前后顺序）设置一个初值为0的信号量，在“前操作”之后V()，在“后操作”之前P()，在不同进程中执行；或初值为n表示一开始有某些资源，则先P()再V()
* 实际上mutex和信号量的区别：mutex只能由申请者释放
* 管程：伪代码的队列类。“把对共享资源的操作封装起来”
* 多线程共享全局变量：如果不同线程对某一变量分别读写或写写，则需要互斥。如果只在一个线程中写或读或是局部变量，则无需互斥

### 生产者-消费者

* 互斥关系：缓冲区是临界资源，必须互斥访问，否则会出现多个写者写同一个位置的情况
* 同步关系：缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待；缓冲区不空时，消费者才能取出产品，否则必须等待
* 因此有三个信号量，一个mutex，一个empty=n，一个full=0。生产者：先生产 P(empty) P(mutex) 把产品放入缓冲区 V(mutex) V(full)。消费者相反，中间取出，最后消费
* 如果把P(mutex)放在P(empty)前面，缓冲区满时会死锁；把P(mutex)放在P(full)前面，缓冲区空时会死锁；但两个V()可以交换
* 多(种)生产者-多消费者
  * 两个生产者各生成一种产品放进盘子，两个消费者各消费一种产品。每个产品各要一个信号量，盘子要一个信号量
  * 因为盘子只有一个，访问它时无需mutex。如果缓冲区有多个就还要一个mutex
  * 应从事件角度考虑：盘子变空->放入水果，前者可由任意一个消费者引发，后者由任意一个生产者执行，因此只需一个信号量。而非从单个进程考虑先后关系
* 吸烟者问题
  * 单生产者产生多种产品，多消费者各消费一种产品，每个产品一个信号量
  * 只有一个缓冲区，用1表示消费完成，初值为0
  * 生产者V(产品) P(盘子)，循环用i=(i+1)%n每轮产生不同对应产品，消费者P(产品) V(盘子)
  * 关键的不同：前面几种盘子初值是m，生产者 P(盘子) 放入 V(产品)；这种完全反了，相当于等待盘子回收。但其实用前面那种好像也可以

### 读者-写者

* 写写互斥，读写互斥，读读不互斥
* rw信号量：初值为1，写者 P(rw) 写文件 V(rw)
* 读者也要持有rw，否则就被写者获得了，但直接获得又不能并发读
* 于是引入count=0，当count=0时P(rw)，否则不获得rw锁，之后count++，读，读完了count--，如果count=1则V(rw)
  * 对count的访问又要加mutex
* 这样是读优先，可能发生写饿死。更公平的改进：在写者外面包一个w，一直持有；读者在处理count和rw周围包它，即在正式读前会释放

### 哲学家进餐

* 圆桌上五个哲学家，每两个哲学家之间有一根筷子，只有拿到左右两根筷子才能吃饭。即需要两个临界资源
* 防止死锁：最多只允许四(n-1)个哲学家同时吃饭
  * 要求奇数号哲学家先拿左边的筷子，偶数号刚好相反
  * 拿两个筷子外包一个mutex。若之后的进程因为无筷子或无mutex而阻塞，等前面的人吃完后释放就能继续了。不考虑“没有两根筷子时释放锁”的逻辑，因为反正死循环下一轮又要拿了
  * 题目变形还有m个碗：用一个初值为min(m, n-1)的信号量

### 死锁

* 对比
  * 死锁：一定是循环等待对方的资源导致的，至少有两个或以上进程同时死锁
  * 饥饿：长时间得不到想要的资源（包括CPU和IO，因此可以是阻塞态，也可以是就绪态），但如果得到了，就可以推进
  * 死循环：由程序的逻辑BUG引起，可以消耗CPU，不是OS关注的问题
* 必要条件：互斥（对互斥资源的争抢）、占有且等待/请求和保持、不可剥夺、循环等待（发生循环等待时未必死锁）
* 对不可剥夺资源的不合理分配，可能导致死锁
* 静态策略，预防死锁
  * 破坏互斥：SPOOLing
  * 破坏不可剥夺：当资源得不到满足时，进程必须立即释放所有资源。第二种方法：由OS将资源强行剥夺。只适用于易保存恢复的资源，如CPU，还可能导致饥饿
  * 破坏请求和保持：静态分配，运行前一次分配。但会导致资源浪费，也可能导致某些进程饥饿
  * 破坏循环等待：对资源采用顺序分配法，进程必须按编号递增的顺序请求资源。但不方便新增设备，也可能导致资源浪费，用户编程麻烦
* 安全序列：按照某种顺序分配资源，每个进程都能顺利完成。安全序列可能有多个。只要有一个，系统就是安全状态。不安全状态下可能发生死锁，安全状态下一定不会死锁
* 动态策略，避免死锁，银行家算法
  1. 已知各个进程含有各个资源的 最大需求、已分配、最多还需要。还已知各个资源剩余可用的
  2. 选择那些还需要的小于可用的，加入安全序列，把它们已分配的资源加入可用的
  3. 重复2，直到全部加入安全序列，则系统处于安全状态，否则处于不安全状态
  4. 另一种题目：在1的状态下，某进程申请某些资源，要求判断是否允许分配。处理方式是“试探分配”，即计算可用的减去申请的，再把申请的加到那个进程已分配的，再判断安全状态。在前面还要判断是否超过了之前确定的最大需求
  * 需要进程运行所需的资源总量信息
  * 通过选破坏循环且等待来避免死锁
* 允许死锁发生，检测和解除
  * 资源分配图：用圈表示进程，矩形和里面的小圈表示资源。箭头由圈指向矩形表示需求，由矩形指向圈表示已分配
    * 依次看各个矩形的小圈数减已分配是否大于需求，如果可以，就加入安全序列，并把进程和它的边都删去
    * 如果最终能清除所有边，称这个图是 可完全简化的。如果不能消除所有边，就是发生了死锁，只有剩下的进程是死锁的，已经消掉的不是
  * 解除死锁的方法：资源剥夺法、撤销(终止)进程法、进程回退法
  * 如何决定对谁动手：优先级、已执行时间、还要多久完成、已经使用了多少资源、是交互式的还是批处理式的
  * “死锁定理”用于检测死锁

## 内存/存储管理

* 相对地址(逻辑地址)、绝对地址(物理地址)
* 链接：产生逻辑地址
  * 静态：运行前，先把各个模块和库函数合并成一个完整的逻辑地址
  * 装入时动态链接：边装入内存边链接
  * 运行时动态链接：程序执行中需要目标模块时才链接，更灵活，便于修改和更新
* 装入：逻辑地址->物理地址
  * 绝对装入：编译时就确定，只适用于单道程序
  * 静态重定位/可重定位装入：地址变换在装入时一次完成。必须分配其要求的全部内存空间，且运行期间不能再移动，也不能再申请空间。适用于多道批处理
  * 动态重定位/动态运行时装入：装入内存后依然是逻辑地址，把地址转换推迟到程序真正要执行时才进行。需要重定位寄存器
* 内存保护
  * 保证不越界访问
  * 可在CPU种设置一对上下限寄存器，放装入后的实际地址
  * 可采用重定位寄存器加界地址寄存器(又称限长寄存器)，后者放最大逻辑地址
* 内存扩充：解决程序大小超过内存总和的问题
  * 覆盖技术：将内存分为固定区和多个覆盖区。假设A调用B和C，B调用D，C调用E和F，且B和C不会同时调用。则让B和C共享一个覆盖区，大小为二者种更大的。但这样必须由程序员声明
  * 交换技术：就是中级调度。磁盘中划分连续分配的对换区。是在不同进程中进行的
  * 虚拟存储技术

### 连续分配

* 内部碎片：分配给某进程的区域中有部分没用上。外部碎片：内存中某些空闲分区因为太小难以利用；可以通过“紧凑”和中级调度解决
* 单一连续分配：只支持单道程序，只有内部碎片。整个划分为系统区和用户区，利用率极低
* 固定分区：支持多道程序，只有内部碎片。用户区划分为几个大小固定（可不相等）的区，每个装一道程序
  * 分区说明表：包括分区号 大小 起始地址 已分配/未分配状态。可以是数组或链表
* 可变分区
  * 只有外部碎片
  * 空闲分区表、空闲分区链：类似于分区说明表
  * 首次适应：从头找适合的分区块。空闲分区以地址依次递增排列，回收分区后无需对队列重新排序，开销小
  * 最佳适应：优先使用最小能满足的分区。空闲分区以容量依次递增排列。会产生许多外部碎片，算法开销大
  * 最坏适应：优先用更大的分区。能减少小碎片，但不利于大进程
  * 临近适应：基本同首次适应，只是每次找的时候从上次找的结束位置开始。会使高地址的大分区也被用完
  * 总的来说，首次适应最好。每次从头找使得也有一些最佳适应的感觉
  * 回收可变分区：上邻接、下邻接、上下邻接、无邻接

### 基本分页

* 把进程分页，使得逻辑上顺序的页面能离散地放到各个内存块中。有少量的内部碎片
* 逻辑块：页/页面page，物理块：页框/帧frame/内存块。两者大小相等，一般为4KB=2^12
* 将32位的地址分为页号和页内偏移两部分，页内偏移占后12位，页号占前20位，内存被分为2^20块，最大内存大小2^20*4KB=4GB
  * 十进制计算：页号=逻辑地址/页面大小，页内偏移=逻辑地址%页面大小。逻辑地址=页号*页面大小+页内偏移
  * 二进制：直接将页号和页内偏移按类似于字符串拼起来即可，其实就是页号占前面的部分，偏移占后面的部分
  * 如页号占10位 0100 0100 00|..，求页号的16进制表示，应从后往前计算补零，即变为0001 0001 0000即110H
* 页表PT
  * 原本“类型”是`dict<页号,块号>`，每一条为一个页表项。但页号是顺序递增的，可以隐含变为`块号[]`
  * 页表项(PTE)长度(大小)最小3B，因为块号只要20位。但为了让每个页面恰好装下整数个页表项，一般用4B，一个页面放2^10个页表项
  * 计算实际页表长度：页表大小/表项大小 或 进程大小/页面大小
  * 计算这个页表需要占用多少个页框：页表大小/页面大小 或 页表长度/一个页面能放的表项数
* 地址转换：计算出页号，查表得到块号（第一次访问内存），与偏移拼接（或理解为替换逻辑地址中的页号部分为块号），得到物理地址。之后如果要取数据就是第二次访存
  * 地址是“一维”的，页大小是已知确定的，只要给出一个逻辑地址，就能算出其它部分
  * 如已知页表物理基址，可计算某一表项的物理地址：页表基址 + 页号*表项大小
* 页表寄存器PTR：存放页表的起始地址和页表长度。进程未执行时此数据放在PCB中，被调度时放入PTR
  * 越界：如果访问的页号超过表项数(页表长度)，会产生越界中断
  * 页表项地址=页表起始地址+页号*页表项长度，取出该内容，即为块号。前面几种情况都假设为页表放在0位置
* 快表
  * 先访问快表，若命中，则再访问数据只需一次访存；多级页表和段页也只用一次。若未命中，找到页表项后，存入快表；有些系统访问快表和访问内存是同时进行的，未命中时不用加访问快表的时间。若页面不在内存中还可能缺页中断访问硬盘
  * 访存时间：命中率 × cache时间 + (1-命中率) × (cache有时不用加但默认加 + 取页表内存)时间 + 取数据内存时间
* 页目录表PDT/顶层页表/外层页表
  * 因为页表项最多2^20个，则页表大小最大2^22B，就需要2^22/2^12=2^10个连续页框来存放。另外没有必要让整个页表常驻内存，可以在页目录表项中加一个 是否在内存中 的字段
  * 所以再把逻辑地址前20位分成两个10位，前10位为一级页号，后10位为二级页号，原页表分为2^10个离散的二级页表，再汇总至页目录表。“类型”类似于`表项[][]`，每一层是连续的，但之间是分散的。访存次数+1
  * 40位地址：一级8位，二级10位，三级10位，偏移12位
* 反置页表/反向页表：另一种管理内存的方式。一个系统只有一个，所有进程共用。页表大小与物理地址空间的大小相同，按物理块排序。表项含有pid和逻辑页号

### 基本分段和段页

* 按照程序自身逻辑划分，比如每个函数一个段，段内连续，之间可以不相邻。写程序时的段名会被翻译成段号(数字)。分段对用户是可见的，分页不可见。会有外部碎片，没有内部碎片
* 更容易实现信息的共享和保护。共享：让不同进程的段表中的某一项指向同一个段，那个段在不同进程中的逻辑段号可以不同。保护：段表项中加一个是否允许其它进程访问的属性；而一个页中的内容可能属于不同的逻辑模块
* 地址是“二维”的，要给出段名和段内地址才能标识一个地址
* 一般用前16位表示段号，后16位表示段内地址。最多2^16个段
  * 地址转换：`段表[段号]`+段内地址。不是进行拼接，而是就是加，因此段表里的值一般较大，因为那些是内存地址而不是编号
* 段表
  * 段表项：占6B，包括段长(2B)和基址(起始位置，4G内存4B)。段号隐含
  * 段表寄存器：段表始址、段表长度
  * 越界：段号超过段表长度、段内地址超过段长（分页不会出现此问题）
* 段页
  * 把每个段分页。16位段号，4位页号，12位页内偏移
  * 段表项：页表长度、页表存放块号。通过它找到页表存放位置
  * 需要三次访存

### 虚拟内存

* 传统管理方式：作业必须一次性全部装入内存后才能开始运行，且之后就一直驻留在内存中，有大量暂时用不到的数据
* 依据：局部性原理。包括时间局部性（某条指令执行后，接下来可能还会执行，因为程序中有循环）和空间局部性（指令是连续存放的）。高速缓冲技术也用到了局部性
* 最大容量：CPU寻址范围2^32。实际容量：min{内存和外存容量之和, 寻址范围}
* 特征：多次性、对换性、虚拟性。前两者刚好解决传统的两个问题。优点：并发、扩容
* 必须建立在离散分配管理的基础上
* 请求调入/调页/调段：当访问的信息不在内存时，由OS负责从外存调入。还要修改快表
* 页面置换：当内存空间不够时，由OS将暂时用不到的换出。如果修改过了需要写回外存
* 请求页表：在基本页表中增加 状态位（是否已调入内存） 访问字段（记录最近访问过几次或上次访问的时间，供置换算法参考） 修改位（调入内存后是否修改过） 外存地址
* 缺页中断：在一条指令执行期间产生并完成。中断无法被预测，不适合实时操作系统。是内中断，一条指令可能引发多次缺页中断，如复制的源和目标都不在内存里。缺页中断未必发生页面置换，只要还有空闲就可以直接调入

#### 页面置换算法

* 以缺页次数作为判断好坏的依据。缺页率=缺页次数/总次数
* 表格第一列(属性)：页走向(访问页面)、内存块1、2、3、是否缺页（如果有，标为+或者勾；第一次调入也算）
* 最佳置换OPT：淘汰现有的项中未来最晚用到的。需要知道之后要访问哪些页，无法实现
* 先进先出FIFO：从上往下依次替换。可能替换掉频繁使用的，效率低
  * 可能发生Belady异常：为进程分配的物理块数增大时，缺页次数不减反增
  * 增大页面大小，缺页次数只可能减小
* 最近最久未使用LRU：访问一次后移到最上面，每次淘汰最下面的，或者直接往前观察。效率好，但需要硬件支持，实现困难开销大。最近最少使用LFU：是按频次不是时间
* 时钟CLOCK/最近未用NUR：将页面链接成循环队列，访问一次把标志位置1，需要替换时扫描第一个为0的，如果当前为1就把标志位置0再扫下一项。淘汰一个页面最多经过两次扫描
* 改进型时钟：优先淘汰未被修改的页面。用(1,1)表示最近访问过且被修改过。第一次扫(0,0)，第二次扫(0,1)并把第一位置0，之后再扫(0,0) (0,1)，后两次相当于扫(1,0) (1,1)。淘汰一个页面最多扫四次

#### 页面分配策略

* 驻留集：给进程分配的物理块集合。OS应为进程选择合适的驻留集大小
* 固定分配：进程运行期间驻留集大小不变。可变分配：可以增加或减少，根据缺页率调整
* 局部置换：缺页时只能选自己的物理块进行置换
* 全局置换：可以分配空闲物理块或其它进程持有的物理块
* 固定分配局部置换、可变分配局部置换、可变分配全局置换
* 何时调入页面
  * 预调页：局部性原理。主要用于进程运行前首次调入
  * 请求调页：就是前面的页面置换
* 何处调入页面
  * 如果对换区足够，可在运行前就将数据从文件区复制到对换区，因为对换区是连续分配的，速度快
  * 如果对换区不够，则不会被修改的数据从文件区调入
  * UNIX方式：首次从文件区调入，之后和对换区交互
* 抖动/颠簸现象：刚换入的页面又被换出。因为分配的物理块不够，需要频繁进行调度
* 工作集：一段时间里进程访问过的页面的集合。OS会根据“窗口大小”算出工作集。一般来说，驻留集大小应大于工作集大小

## 文件系统

* 文件是一种抽象机制，提供了把数据保存在外存上的方法
* 打开文件：每个进程有一个打开文件表，整个系统有一张系统的打开文件表。前者有指向后者的指针，不同进程访问权限可以不同，后者有打开计数器
* 文件保护：访问控制表ACL。属于存取控制模块层次

### 逻辑结构

* 无结构文件/流式文件：如txt
* 有结构文件/记录式文件：类似于数据库表，有一个数据项作为关键字。又分为定长记录和变长记录
  * 顺序文件
    * 物理上可以顺序存储(连续)或链式存储。默认前者
    * 只有顺序文件才能存储在磁带、光盘上。磁盘是“直接存取”(随机存取)的设备
    * 串结构：记录之间的顺序与关键字无关，一般按插入时间
    * 顺序结构：记录之间的顺序按关键字排列，可快速查找(折半)某关键字对应的记录。其余情况查找时每次平均要找记录长度的一半的数量
    * 顺序存储+定长记录：可实现随机存取，记录位置是i*L。链式存储和顺序存储+可变长结构：每次只能从第一个记录项开始依次往后找
  * 索引文件：建立索引表{索引号,长度,指针}，此表本身是定长记录的顺序文件
  * 索引顺序文件：不对每一个记录建立一个表项，而是先分组，比如A开头的放一组。最外层的索引表是定长记录串结构的顺序文件。还可以建立多级索引，总查找次数是每层相加

### 目录结构

* FCB文件控制块：目录下的文件的FCB存在于目录文件自身的内容中，一条记录就是一个FCB，包括文件名 类型 存取权限 物理地址 等
* 单级：整个系统只建立一张目录表，这样不允许重名
* 两级：早期多用户系统分为主文件目录MFD和用户文件目录UFD，不同用户文件允许重名，还能实现不同用户访问限制
* 多级/树形：现在的结构。查询/a/b/c.txt的存放位置需要三次IO
* 有向无环图：在树形基础上，对相同的文件（可用不同的文件名）指向同一个对象
* 文件共享
  * 基于索引的共享方式(硬链接)：FCB中只放文件名和索引结点指针，索引结点包含Count和文件的物理地址。能减少目录项的大小，提升文件检索速度。在外存中的索引结点称为磁盘索引结点，放入内存后称为内存索引结点
  * 基于符号链的共享方式(软链接)：Link型的文件记录了实际文件的路径

### 物理结构

* 磁盘块：一般为4KB，或与内存块大小相同。文件的逻辑地址就可表示为(逻辑块号,块内地址)，之后再把逻辑转换为物理
* 连续分配：要求占有连续的物理块。在FCB中记录起始块号和文件长度(几块)。支持随机访问(直接访问)。缺点：不便拓展、会产生磁盘碎片
* 链接分配
  * 隐式链接（默认）：FCB中记录起始块号和结束块号，每一块再存放指向下一块的指针。只支持顺序访问，不支持随机访问
  * 显式链接：文件分配表FAT。以物理块号排序并连续存储隐含，值是下一块的索引，最后一块为-1。FCB中只要放起始块号。一个磁盘对应一个FAT，常驻内存，转换操作不需要IO
  * 消除了外部碎片
* 索引分配

#### FAT

* 表项大小是0.5B的整数倍，FAT32的表项大小为4B
* 能管理的最大磁盘空间：见索引分配。但事实上FAT32的高四位是不用的，磁盘块4KB时就是1TB。又MBR在引导区只使用4B记录扇区数，即硬盘总大小2T
* 磁盘块的数量(FAT表长度) = 分区容量 / 磁盘块大小。整个FAT表的大小 = 磁盘块的数量 × 表项大小
* 支持的单文件最大大小，FAT32是4GB，因为文件长度用4B储存

#### 索引分配

* 每个文件建立一张索引表，记录逻辑块(隐含)-物理块的对应关系。FCB中记录索引块的物理块号，里面放索引表。支持随机访问、方便拓展
* 假如每个磁盘块1KB，一个索引表项4B，则一个磁盘块最多放256个表项。若磁盘块4KB，则有1024个表项
* 能管理的最大磁盘空间 = 2^32表项位数 × 1KB磁盘块大小 = 4TB
* 链接方案：每个索引块有指向下一个块的指针。如果要找到最后一个块，必须顺序读，很多次IO
* 多层索引/多级间接
  * 类似于多维数组。如二层索引，最外层的叫一级索引表，下一层叫二级索引表
  * 如逻辑块号为1026，则算1026/256=4，在一级索引表取下标4的二级索引表，再取1026%256=2
  * 算上读文件内容，几级就要几+1次IO；但也可能顶级表在内存中
  * 最大文件大小 = (磁盘块大小/表项大小) × 索引级数 × 磁盘块大小。如1KB磁盘块两层索引，文件最大256×256×1KB=64MB
* 混合索引
  * 解决小文件需要多次IO读多层索引表
  * 0-9号是直接索引 10×1KB=10KB，每个指向一个物理块
  * 10号是一级间接索引 1×256×1KB=256KB
  * 11号是二级间接索引 1×256×256×1KB=64MB
* 计算间接盘块：没有看懂。直接索引属不属于间接盘块？一个一级间接索引算一个还是算1+256个？

### 空闲空间管理/存储空间管理

* 空闲表法：(第一个空闲盘块号, 空闲盘块数)。为文件分配连续的空间，可采用首次适应、最佳适应等。回收时会合并
* 空闲链表法：空闲盘块链、空闲盘区链。后者每个区的第一个盘块含有此盘区的长度和指向下一个盘区的指针。分配时从链头取下，回收时挂到链尾
* 位示图
  * 类似于二维数组，0代表空闲，一行代表一个“字”，一个字可以是16位，用(字号,位号)表示
  * 若盘块号、字号、位号都从0开始，则b=ni+j，i=b/n，j=b%n
  * 若都从1开始：b=n(i-1)+j，i=(b-1)/n+1，j=(b-1)%n+1
* 成组链接法

### 磁盘结构

* 磁道：同心圆
* 扇区：中间向四周画射线，两条射线之间的区域。每个扇区存放的数据量相同，中心更密
* 盘面：有时一个盘片可能对应两个盘面
* 柱面：所有盘面中相对位置相同的磁道
* 磁头：每个盘面对应一个磁头，所有磁头连在同一个磁臂上，只能同进退。另外还有固定头磁盘，每个磁道有一个磁头，磁头本身不移动
* 磁盘地址：(柱面号, 盘面号, 扇区号)

### 磁盘调度

* 访问时间
  * 寻道时间/寻找时间Ts = 启动时间s + 跨越的磁道数n * 每移动一条磁道所需的时间m
  * 旋转延迟时间Tr（将目标扇区转到磁头下面所花的时间） = 旋转半圈的时间1/2r
  * 传输时间Tt = 旋转一圈的时间（读取完一个磁道）1/r * 此次读写的字节数b/每个磁道上的字节数N（即要读多少个磁道）
* 优化寻道时间（移臂调度）
  * 平均寻找长度：移动的磁道数/请求次数
  * 先来先服务FCFS：按请求的顺序移动。磁道分散时性能差
  * 最短寻道时间优先SSTF：可保证每次寻道时间最短，但不保证总时间最短。但可能产生饥饿
  * 扫描算法SCAN/电梯算法：移动到最外侧后才能往内移动，反过来也一样。LOOK算法：不用移动到磁盘的最外侧，只要到请求的最边上即可。有利于中间的请求
  * 循环扫描算法C-SCAN：单向扫描，返回时直接移动到起始端而不处理任何请求。C-LOOK：如果移动方向上没有请求了就立即返回，且返回到最开始有请求的
  * 若没有特别说明，SCAN指的是LOOK，C-SCAN指的是C-LOOK
* 优化延迟时间（旋转调度）
  * 磁头读完一个扇区后，需要一小段时间处理，不能连续读取。如果逻辑上相邻的扇区在物理上也相邻，则读取了一个后就会错过下一个
  * 交替编号：如一圈编号为 0 4 1 5 2 6 3 7
  * 地址结构：如果用(盘面号, 柱面号, 扇区号)，读连续的地址，当用完扇区号后就要移动柱面，而前面那种方式只要激活另一个盘面的磁头
  * 错位命名：如0号盘面的0号扇区的物理位置对应1号盘面的7号，0号盘面的7号扇区对应1号盘面的3号。这样读完0,111后再读1,000，不是1号盘面对应物理位置上的下一块，而是下下块

## 设备管理

* IO设备分类：输入输出。人机交互、存储、网络通信。低速、中速、高度。块设备、字符设备

### IO控制器

* IO设备含有机械部件（看得见摸得着的）和电子部件（电路板），后者就是IO控制器，是CPU和机械部件的中介
* 包括 CPU和控制器之间的接口、IO逻辑（负责识别CPU指令并向设备发出命令）、控制器与设备之间的接口
* 可以识别CPU发出的指令（控制寄存器）、向CPU报告设备的状态（状态寄存器、空闲/忙碌）、数据交换（数据寄存器）、地址识别
* 一个IO控制器可控制多个IO设备
* 寄存器可能有多个，它们要有地址。有的和内存一起编址，称为内存映像；有的是独立编址

### IO控制方式

* 程序直接控制：CPU发出指令后轮询状态寄存器是否完成，完成后把数据从控制器的数据寄存器传到CPU的寄存器，再传到内存，且一次只能读写一个字
* 中断驱动：CPU发出指令后可以做其它事，本次IO完成后设备控制器发出中断信号，因此CPU和IO设备可以并行工作。但还是要传到CPU再传到内存，还是一次一个字
* DMA：CPU指明此次操作是读还是写、内存地址、长度等，由DMA控制器与内存交互，操作完后中断通知CPU。一次可读写多个连续块，如果块离散，仍要多次处理
* 通道控制：通道是一种硬件，可看作弱化CPU，一个通道可控制多个IO控制器。先在内存中一个位置写好通道程序（由通道指令组成），CPU与通道通信，通道按程序中的指令执行。一次可处理一组块

### IO软件层次结构

* 用户层软件：如printf
* 设备独立性软件
  * 又称为系统调用处理层、设备无关性软件
  * 向上层提供系统调用接口，处理完后会翻译成write
  * IO调度：用某种算法确定顺序处理请求，如磁盘调度、打印机调度
  * 设备保护：类似于文件的保护（文件权限，只读、读写）
  * 差错处理
  * 设备的分配与回收：设备一般是临界资源
  * 数据缓冲区管理：屏蔽各个设备之间数据交换大小和传输速度差异
  * 建立逻辑设备名（文件名）和物理设备名的映射关系，根据设备类型选择相应的驱动程序，放进逻辑设备表LUT
* 设备驱动程序：负责对设备的具体控制，将write转换为特定设备“听得懂”的操作
* 中断处理程序：IO完成后控制器会发送中断信号，OS根据信号类型执行对应的中断处理程序
* IO核心子系统/IO系统：就是以上三种。另外SPOOLing属于用户层软件，但也属于IO系统

### SPOOLing假脱机技术/虚拟设备

* 脱机技术：批处理阶段、磁带。缓解速度矛盾。脱离主机的控制进行IO
* 输入井（磁盘上，接受外围设备的输入）、输出井（接受用户进程的输出）、输入进程（内存中）、输出进程、缓冲区
* 将一台独占设备虚拟成多台逻辑设备，以空间换时间。每个进程都觉得自己在独占设备
* 目的是为了提高IO设备（不是CPU）的使用效率

### 设备分配

* 静态分配：破坏了“请求和保持”
* 设备控制表DCT：包括设备类型（如打印机 键盘） 标识符（即物理名） 状态（忙碌 空闲 故障） 一个指向控制器表的指针 正在等待使用该设备的进程队列的队首指针
* 控制器控制表COCT：一个指向通道表的指针 等待使用该控制器的进程队列的指针
* 通道控制表CHCT：与 通道连接的控制器 表首址（一个通道对应多个控制器） 等待使用该通道的进程队列的指针
* 系统设备表SDT：每个设备对应一个表项，里面有指向DCT的指针
* 分配步骤：根据进程请求的物理设备名，在SDT中查找DCT。若设备忙则挂到设备等待队列中，空闲则分配设备。再扎到COCT和CHCT，重复刚才的步骤
  * 改进：根据进程请求的逻辑设备名，查找一个空闲的设备分配，并在逻辑设备表LUT中新增表项
* 将每一台设备按某种原则进行统一编号，作为区分硬件和设备的代号，该编号称为设备的：绝对号

### 缓冲区

* 解决CPU和IO设备速度不匹配的问题、减少中断频率、提高并行性
* 一个缓冲区就是一个块，为空时只能写不能读直到充满，非空时只能读不能写
* 常见题型：处理一块数据平均用时多久
  * 设设备到缓冲区(输入)耗时T，缓冲区到用户进程工作区(传送)耗时M，CPU处理耗时C
  * 技巧：假定一个初始状态（工作区满缓冲区空），分析下次到达同样的状态需要多久。将三者画在同一个耗时图中
* 单缓冲：讨论C和T的大小。处理一块数据平均耗时Max(C,T)+M
* 双缓冲：讨论T和C+M的大小。处理一块数据平均耗时Max(T,C+M)
* 循环缓冲区/队列：in指向下一个可以冲入的空缓冲区，out指向下一个可以取出的满缓冲区
* 缓冲池：
  * 分为空缓冲队列、输入队列、输出队列
  * 根据不同功能又设置了四种工作缓冲区：收容输入hin、提取输入sin、收容输出hout、提取输出sout
  * 硬件输入：从空队列队头取下一块，放到hin，充满后挂到输入队列队尾上
  * 计算进程取得输入数据：从输入队列队头取下一块，放到sin，取空后挂到空队列队尾

## 参考

* https://www.bilibili.com/video/BV1YE411D7nH

### TODO

```
https://zhuanlan.zhihu.com/p/565012118

PV：
两个生产者，要求A的数量-B的数量<M，且B的数量-A的数量<N：
semaphore Sa=M-1,Sb=N-1; 前者代表A与B还可容纳的数量差
生成A中P(Sa); V(Sb)

一个消费者需要多个不同的生产者生产的资源时，需限制生产的最大值小于容量-消费者所需的某个值，否则当容量都被某一种占满时就发生了死锁。



虚拟内存的最大容量：2^地址位数。与内存+外存大小无关，因为那是实际容量的因素之一。
虚拟内存页表项中，决定是否会发生页故障的是：合法位
提供虚拟内存技术的存储管理方法有：请求分页/分段/段页存储管理。单说页式存储管理是错的，必须要有请求

覆盖技术：把程序分段，固定区不变，覆盖区根据需要装入，对程序员不透明，只用于单道程序和单一连续分配。交换技术：把不需要的进程换到外存，但必须整个换进程

多级页表：访问哪一个二级页表看的是页目录号

进程正在进行IO操作时不能换出内存，但可以开辟缓冲区，当缓冲区和外设IO时，进程交换不受限制。处于临界区时，若是普通临界区，可以被换出，内核临界区不行。死锁时可以


磁盘：
间接盘块数量：只算最后一层非物理块的，(TODO: 现有笔记中的是错的)。访问处于n级索引上的数据，需要访问磁盘n+1次

https://www.zhihu.com/question/557997114 扇区到底是盘片上的一段圆弧还是盘片上的一部分圆

一个可共享的程序在执行过程中是不能被修改的，称为可重入代码
```
