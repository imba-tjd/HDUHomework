# 实验三(4)：共享内存进程通信

实验要求：

使用共享内存实现两个进程间的通信。

## 理论知识

* 共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改
* 因为所有进程共享同一块内存，共享内存在各种进程间通信方式中具有最高的效率。访问共享内存区域和访问进程独有的内存区域一样快，并不需要通过系统调用或者其它需要切入内核的过程来完成。同时它也避免了对数据的各种不必要的复制
* 因为系统内核没有对访问共享内存进行同步，您必须提供自己的同步措施。例如，在数据被写入之前不允许进程从共享内存中读取消息、不允许两个进程同时向同一个共享内存地址写入数据等。解决这些问题的常用方法是通过使用信号量进行同步

## 共享内存库的两种实现

* 共享内存同样分为System V方式和POSIX方式两种。前者的头文件为`sys/ipc.h`和`sys/shm.h`，使用的函数为`shmget`、`shmat`、`shmdt`、`shmctl`
* POSIX方式的头文件为`mman.h`和`fcntl.h`，使用的函数为`shm_open`、`shm_unlink`、`mmap`、`munmap`、`msync`，注意打开的共享内存的名字需要符合POSIX标准

## 其他人的实现

因为当时我做的时候没有抄其他人的，最初的版本实现得不好。老师问了一些很苛刻的问题，我进行了一些思考，但可能并不合适。后来我明白程序有一定的适用范围是很正常的。

总地来说此实验不推荐用我的版本，可以参考这个库：<https://github.com/mushroom-x/OS-Assignment-2016/tree/master/4_Linux_Progress_Control/4_5_shared_memory>

## 我实际实现的程序的思路

1. 读取和写入的时候都挂锁。但这样同一时间只能有一个读或写。
2. 写入时，使用strcat把消息接到上一个末尾。因为是用fget读取的，自带\n。然后发送sendSig信号量。
3. 读取时，等待sendSig信号量，直接使用fputs全部输出，多条消息自动换行。然后把共享内存区域清空。
4. 不能用memcpy/strcpy，不然会覆盖之前的内容。

这样其实仅限于传递长度有限的字符串。

## 理想状态下可能需要实现的特性

1. 是否存在超过共享内存容量的消息：是
2. 消息大小是否已知：否
3. 是否可能有多个receiver：是
4. 是否可能有多个sender：是
5. 满足3时，同一sender可否指定不同消息发送到不同的receiver、可否指定一条消息对应多个receiver：可
6. 一条消息对应多个receiver时可否并发读取：可；先读取完某一条消息的不需要阻塞等待其他读取完毕：是
7. 接收到的消息是否应该按照发送的顺序输出：是
8. receiver在读取的时候sender是否仍然可以继续发送：是
9. 满足1、2时，是否应该让超过当前剩余容量但是不超过最大大小的消息的阻塞：否

## 增加部分特性的理论实现

### 版本一

1. 单sender，多receiver。
2. 只要共享内存未满，sender写入时不会阻塞。通信类内部指示当前可写入的位置。如果共享内存剩余大小大于发送的消息，则正常写入并标识该消息结束；如果小于，把空闲的全部使用，把可写入位置移动到最后，并等待“清空”的信号量；收到后再从头继续发送未发完的。以上两种情况完成后都发送一个“已发送”的信号量。
3. receiver收到“已发送”的信号量的时候，检测自己是不是最后一个收到的（要求已知receiver数量），如果不是，则再次释放“已发送”的信号量给别的接收者。然后开始读取。通信类内部指示当前待读取的位置。读取结束后，检测自己是不是最后一个读取完的，如果是，则移动当前待读取的位置；并且检测当前可写入的位置是否是末尾，如果是，则清空共享内存，并释放“清空”的信号量。
4. 检测自己是不是最后一个收到的和检测自己是不是最后一个读取完的用原子操作实现。所以总共只要两个信号量，而且没有锁。

但以上操作有两个问题，一是不同消息的“已发送”信号量会和控制多receiver的信号量混在一起；二是先读取完某一条消息的需要阻塞等待其他读取完毕，因为没法标识不同消息里多少receiver进入了和退出了。所以实际上是不能用的。

### 版本二

1. 为了解决receiver的”调度“问题，需要一个内部的主receiver把消息发给其他的，则主sender需要持有其他receiver的“已发送”信号量；这样可以在消息头里添加发给指定reveiver的消息，主receiver根据消息释放指定的信号量，则可以做到指定不同消息发送到不同的receiver以及消息对应多个指定receiver。当前待读取的位置则变为主receiver的局部变量，只要传给指定reveiver后往后移即可。当需要清空时，因为共享内存是共有的，必须等待其他receiver读完，所以每一个都需要”读完“信号量。。
2. 信号量数量：其他receiver的数量 * 2 + 2（主reveiver接收和发送的“已发送”和“清空”）。
3. 该方案可以做到多个receiver读取之前的消息的时候，sender仍然进行写入。因为当前可写入的位置和当前待读取的位置是互不干扰的。并且该方案无锁。
4. 该方案无法做到多个sender同时写入，因为如果共享内存满了消息没有发完，清空后变成另一个sender接着发呢？而且消息的大小也是不知道的，写的时候也要加锁。但是如果不要求同时并且receiver接收以后能够立即处理（否则需要有能够接收所有数据的容量）则可以在消息头里加sender消息。

如果要多个sender同时写入，我认为需要用网络的模式，把消息分成小包，这样消息的大小会变成数量未知但大小固定的包；当前可写入的位置的移动使用原子操作。但receiver接收到后还是需要立即处理。

## 问题

参见[issue#3](https://github.com/imba-tjd/HDUHomeWork/issues/3)。

## 参考

* <https://zhuanlan.zhihu.com/p/37808566>
* <http://www.cnblogs.com/charlesblc/p/6261469.html>
